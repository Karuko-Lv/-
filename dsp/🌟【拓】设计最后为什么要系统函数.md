这是一个非常深刻的问题，触及了数字信号处理（DSP）工程实现的本质。

你可以把 $H(z)$ 理解为这个滤波器的**“工程蓝图”**或**“DNA”**。

虽然我们在设计过程中可能会看时域的 $h[n]$（如加窗法），或者看频域的 $H(e^{j\omega})$（如看截止频率），但最终都要回归到 $H(z)$，主要有以下 **4 个核心原因**：

### 1. 它是代码和硬件实现的直接依据（最重要）

我们在计算机、DSP芯片或FPGA里实现滤波器时，机器看不懂“截止频率是500Hz”，也处理不了无限长的公式。机器只需要一样东西：**差分方程（Difference Equation）**。

$H(z)$ 能够直接转化为差分方程。

假设你得到了这样一个 $H(z)$：

$$H(z) = \frac{Y(z)}{X(z)} = \frac{b_0 + b_1 z^{-1}}{1 - a_1 z^{-1}}$$

只需一步简单的交叉相乘和变换，就能得到代码逻辑：

$$y[n] = b_0 x[n] + b_1 x[n-1] + a_1 y[n-1]$$

- **$b$ 和 $a$**：这就是你在代码里定义的数组（系数）。
    
- **$z^{-1}$**：这就是代码里的“延时”或“存储上一个采样点”。
    

**结论：** 拿到 $H(z)$，就等于拿到了系数 $a_k, b_k$，程序员才能写出代码 $y[n] = \dots$。

### 2. 它是分析系统稳定性（Stability）的神器

有些滤波器设计出来可能是“炸”的（不稳定的），特别是 IIR 滤波器。

- **时域 $h[n]$**：很难一眼看出是否发散，特别是当 $n$ 很大时。
    
- **频域 $H(\omega)$**：只能看到频率响应，看不出稳定性。
    
- **$Z$ 域 $H(z)$**：这是唯一的判据。
    
    - 我们只需要求 $H(z)$ 分母的根（**极点，Poles**）。
        
    - 只要所有极点都在 $z$ 平面的**单位圆内**（模小于1），系统就是稳定的。
        

**结论：** $H(z)$ 提供了零极点分布图，是安全检查的唯一标准。

### 3. 它决定了滤波器的结构（Topology）

同一个滤波器可以有多种“搭积木”的方式（直接I型、直接II型、级联型、并联型）。

- 如果你保持 $H(z)$ 是一个大分式，对应的是**直接型**结构（对系数精度要求极高，容易产生误差）。
    
- 如果你把 $H(z)$ 因式分解成多个二阶节（SOS）的乘积：
    
    $$H(z) = H_1(z) \cdot H_2(z) \cdot \dots$$
    
    这就对应级联型结构（工程上最常用，抗量化噪声能力强）。
    

**结论：** 对 $H(z)$ 的数学变形，直接决定了电路图怎么画，或者代码怎么优化。

### 4. 它是连接时域和频域的桥梁

$H(z)$ 是一个高度抽象的统一体：

- **想去频域？** 令 $z = e^{j\omega}$，马上得到幅频响应和相频响应。
    
- **想去时域？** 做反变换，马上得到冲击响应 $h[n]$。
    

### 总结

你设计滤波器时的过程可能是：

1. **需求**（我要滤掉50Hz噪音） -> **频域指标**。
    
2. **手段**（加窗、双线性变换） -> **数学计算**。
    
3. **终点**（得到 $H(z)$） -> **交付物**。
    

因为只有拿到了 $H(z)$（实际上是拿到了一组系数 $a$ 和 $b$），你才能自豪地把数据交给软件工程师说：“喏，把这组数填进程序里，滤波器就做好了。”

---

接下来的这一步非常关键：

既然知道了 $H(z)$ 对应差分方程，通过系数 $a$ 和 $b$ 来实现。你想了解一下 $H(z)$ 的系数精度（比如是用 float 还是 int 存储）对滤波器性能会有什么“致命”影响吗？（这在实际工程中是个大坑）。